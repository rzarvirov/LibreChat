{"code":"export {};\n//# sourceMappingURL=agents.js.map","references":["/Users/romanzarvirov/aibuddy/LibreChat/packages/data-provider/src/types/runs.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/data-provider/src/types/assistants.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/data-provider/src/schemas.ts"],"map":"{\"version\":3,\"file\":\"agents.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/types/agents.ts\"],\"names\":[],\"mappings\":\"\"}","dts":{"name":"/Users/romanzarvirov/aibuddy/LibreChat/packages/data-provider/dist/types/types/agents.d.ts","writeByteOrderMark":false,"text":"import { StepTypes, ContentTypes, ToolCallTypes } from './runs';\nimport type { FunctionToolCall } from './assistants';\nimport type { TAttachment } from 'src/schemas';\nexport declare namespace Agents {\n    type MessageType = 'human' | 'ai' | 'generic' | 'system' | 'function' | 'tool' | 'remove';\n    type ImageDetail = 'auto' | 'low' | 'high';\n    type ReasoningContentText = {\n        type: ContentTypes.THINK;\n        think: string;\n    };\n    type MessageContentText = {\n        type: ContentTypes.TEXT;\n        text: string;\n        tool_call_ids?: string[];\n    };\n    type MessageContentImageUrl = {\n        type: ContentTypes.IMAGE_URL;\n        image_url: string | {\n            url: string;\n            detail?: ImageDetail;\n        };\n    };\n    type MessageContentComplex = ReasoningContentText | MessageContentText | MessageContentImageUrl | (Record<string, any> & {\n        type?: ContentTypes | string;\n    }) | (Record<string, any> & {\n        type?: never;\n    });\n    type MessageContent = string | MessageContentComplex[];\n    /**\n     * A call to a tool.\n     */\n    type ToolCall = {\n        /** Type (\"tool_call\") according to Assistants Tool Call Structure */\n        type: ToolCallTypes.TOOL_CALL;\n        /** The name of the tool to be called */\n        name: string;\n        /** The arguments to the tool call */\n        args?: string | Record<string, any>;\n        /** If provided, an identifier associated with the tool call */\n        id?: string;\n        /** If provided, the output of the tool call */\n        output?: string;\n    };\n    type ToolEndEvent = {\n        /** The Step Id of the Tool Call */\n        id: string;\n        /** The Completed Tool Call */\n        tool_call?: ToolCall;\n        /** The content index of the tool call */\n        index: number;\n    };\n    type ToolCallContent = {\n        type: ContentTypes.TOOL_CALL;\n        tool_call?: ToolCall;\n    };\n    /**\n     * A chunk of a tool call (e.g., as part of a stream).\n     * When merging ToolCallChunks (e.g., via AIMessageChunk.__add__),\n     * all string attributes are concatenated. Chunks are only merged if their\n     * values of `index` are equal and not None.\n     *\n     * @example\n     * ```ts\n     * const leftChunks = [\n     *   {\n     *     name: \"foo\",\n     *     args: '{\"a\":',\n     *     index: 0\n     *   }\n     * ];\n     *\n     * const leftAIMessageChunk = new AIMessageChunk({\n     *   content: \"\",\n     *   tool_call_chunks: leftChunks\n     * });\n     *\n     * const rightChunks = [\n     *   {\n     *     name: undefined,\n     *     args: '1}',\n     *     index: 0\n     *   }\n     * ];\n     *\n     * const rightAIMessageChunk = new AIMessageChunk({\n     *   content: \"\",\n     *   tool_call_chunks: rightChunks\n     * });\n     *\n     * const result = leftAIMessageChunk.concat(rightAIMessageChunk);\n     * // result.tool_call_chunks is equal to:\n     * // [\n     * //   {\n     * //     name: \"foo\",\n     * //     args: '{\"a\":1}'\n     * //     index: 0\n     * //   }\n     * // ]\n     * ```\n     *\n     * @property {string} [name] - If provided, a substring of the name of the tool to be called\n     * @property {string} [args] - If provided, a JSON substring of the arguments to the tool call\n     * @property {string} [id] - If provided, a substring of an identifier for the tool call\n     * @property {number} [index] - If provided, the index of the tool call in a sequence\n     */\n    type ToolCallChunk = {\n        name?: string;\n        args?: string;\n        id?: string;\n        index?: number;\n        type?: 'tool_call_chunk';\n    };\n    /** Event names are of the format: on_[runnable_type]_(start|stream|end).\n  \n    Runnable types are one of:\n  \n    llm - used by non chat models\n    chat_model - used by chat models\n    prompt -- e.g., ChatPromptTemplate\n    tool -- LangChain tools\n    chain - most Runnables are of this type\n    Further, the events are categorized as one of:\n  \n    start - when the runnable starts\n    stream - when the runnable is streaming\n    end - when the runnable ends\n    start, stream and end are associated with slightly different data payload.\n  \n    Please see the documentation for EventData for more details. */\n    type EventName = string;\n    type RunStep = {\n        type: StepTypes;\n        id: string;\n        runId?: string;\n        index: number;\n        stepIndex?: number;\n        stepDetails: StepDetails;\n        usage: null | {};\n    };\n    /**\n     * Represents a run step delta i.e. any changed fields on a run step during\n     * streaming.\n     */\n    interface RunStepDeltaEvent {\n        /**\n         * The identifier of the run step, which can be referenced in API endpoints.\n         */\n        id: string;\n        /**\n         * The delta containing the fields that have changed on the run step.\n         */\n        delta: ToolCallDelta;\n    }\n    type StepDetails = MessageCreationDetails | ToolCallsDetails;\n    type MessageCreationDetails = {\n        type: StepTypes.MESSAGE_CREATION;\n        message_creation: {\n            message_id: string;\n        };\n    };\n    type ToolCallsDetails = {\n        type: StepTypes.TOOL_CALLS;\n        tool_calls: AgentToolCall[];\n    };\n    type ToolCallDelta = {\n        type: StepTypes.TOOL_CALLS | string;\n        tool_calls?: ToolCallChunk[];\n    };\n    type AgentToolCall = FunctionToolCall | ToolCall;\n    interface ExtendedMessageContent {\n        type?: string;\n        text?: string;\n        input?: string;\n        index?: number;\n        id?: string;\n        name?: string;\n    }\n    /**\n     * Represents a message delta i.e. any changed fields on a message during\n     * streaming.\n     */\n    interface MessageDeltaEvent {\n        /**\n         * The identifier of the message, which can be referenced in API endpoints.\n         */\n        id: string;\n        /**\n         * The delta containing the fields that have changed on the Message.\n         */\n        delta: MessageDelta;\n    }\n    /**\n     * The delta containing the fields that have changed on the Message.\n     */\n    interface MessageDelta {\n        /**\n         * The content of the message in array of text and/or images.\n         */\n        content?: Agents.MessageContentComplex[];\n    }\n    /**\n     * Represents a reasoning delta i.e. any changed fields on a message during\n     * streaming.\n     */\n    interface ReasoningDeltaEvent {\n        /**\n         * The identifier of the message, which can be referenced in API endpoints.\n         */\n        id: string;\n        /**\n         * The delta containing the fields that have changed.\n         */\n        delta: ReasoningDelta;\n    }\n    /**\n     * The reasoning delta containing the fields that have changed on the Message.\n     */\n    interface ReasoningDelta {\n        /**\n         * The content of the message in array of text and/or images.\n         */\n        content?: MessageContentComplex[];\n    }\n    type ReasoningDeltaUpdate = {\n        type: ContentTypes.THINK;\n        think: string;\n    };\n    type ContentType = ContentTypes.THINK | ContentTypes.TEXT | ContentTypes.IMAGE_URL | string;\n}\nexport type ToolCallResult = {\n    user: string;\n    toolId: string;\n    result?: unknown;\n    messageId: string;\n    partIndex?: number;\n    blockIndex?: number;\n    conversationId: string;\n    attachments?: TAttachment[];\n};\n"}}
