{"code":"export {};\n//# sourceMappingURL=mcp.js.map","references":["/Users/romanzarvirov/aibuddy/LibreChat/node_modules/zod/index.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/data-provider/dist/types/index.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/data-provider/dist/types/index.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/types.d.ts"],"map":"{\"version\":3,\"file\":\"mcp.js\",\"sourceRoot\":\"\",\"sources\":[\"../../../src/types/mcp.ts\"],\"names\":[],\"mappings\":\"\"}","dts":{"name":"/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/dist/types/types/mcp.d.ts","writeByteOrderMark":false,"text":"import { z } from 'zod';\nimport { SSEOptionsSchema, MCPOptionsSchema, MCPServersSchema, StdioOptionsSchema, WebSocketOptionsSchema } from 'librechat-data-provider';\nimport type { JsonSchemaType, TPlugin } from 'librechat-data-provider';\nimport { ToolSchema, ListToolsResultSchema } from '@modelcontextprotocol/sdk/types.js';\nexport type StdioOptions = z.infer<typeof StdioOptionsSchema>;\nexport type WebSocketOptions = z.infer<typeof WebSocketOptionsSchema>;\nexport type SSEOptions = z.infer<typeof SSEOptionsSchema>;\nexport type MCPOptions = z.infer<typeof MCPOptionsSchema>;\nexport type MCPServers = z.infer<typeof MCPServersSchema>;\nexport interface MCPResource {\n    uri: string;\n    name: string;\n    description?: string;\n    mimeType?: string;\n}\nexport interface LCTool {\n    name: string;\n    description?: string;\n    parameters: JsonSchemaType;\n}\nexport interface LCFunctionTool {\n    type: 'function';\n    ['function']: LCTool;\n}\nexport type LCAvailableTools = Record<string, LCFunctionTool>;\nexport type LCToolManifest = TPlugin[];\nexport interface MCPPrompt {\n    name: string;\n    description?: string;\n    arguments?: Array<{\n        name: string;\n    }>;\n}\nexport type ConnectionState = 'disconnected' | 'connecting' | 'connected' | 'error';\nexport type MCPTool = z.infer<typeof ToolSchema>;\nexport type MCPToolListResponse = z.infer<typeof ListToolsResultSchema>;\nexport type ToolContentPart = {\n    type: 'text';\n    text: string;\n} | {\n    type: 'image';\n    data: string;\n    mimeType: string;\n} | {\n    type: 'resource';\n    resource: {\n        uri: string;\n        mimeType?: string;\n        text?: string;\n        blob?: string;\n    };\n};\nexport type ImageContent = Extract<ToolContentPart, {\n    type: 'image';\n}>;\nexport type MCPToolCallResponse = undefined | {\n    _meta?: Record<string, unknown>;\n    content?: Array<ToolContentPart>;\n    isError?: boolean;\n};\nexport type Provider = 'google' | 'anthropic' | 'openAI';\nexport type FormattedContent = {\n    type: 'text';\n    text: string;\n} | {\n    type: 'image';\n    inlineData: {\n        mimeType: string;\n        data: string;\n    };\n} | {\n    type: 'image';\n    source: {\n        type: 'base64';\n        media_type: string;\n        data: string;\n    };\n} | {\n    type: 'image_url';\n    image_url: {\n        url: string;\n    };\n};\nexport type ImageFormatter = (item: ImageContent) => FormattedContent;\nexport type FormattedToolResponse = [\n    string | FormattedContent[],\n    {\n        content: FormattedContent[];\n    } | undefined\n];\n"}}
