{"code":"import { __awaiter } from \"tslib\";\nimport { EventEmitter } from 'events';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport { SSEClientTransport } from '@modelcontextprotocol/sdk/client/sse.js';\nimport { StdioClientTransport } from '@modelcontextprotocol/sdk/client/stdio.js';\nimport { WebSocketClientTransport } from '@modelcontextprotocol/sdk/client/websocket.js';\nimport { ResourceListChangedNotificationSchema } from '@modelcontextprotocol/sdk/types.js';\nfunction isStdioOptions(options) {\n    return 'command' in options;\n}\nfunction isWebSocketOptions(options) {\n    if ('url' in options) {\n        const protocol = new URL(options.url).protocol;\n        return protocol === 'ws:' || protocol === 'wss:';\n    }\n    return false;\n}\nfunction isSSEOptions(options) {\n    if ('url' in options) {\n        const protocol = new URL(options.url).protocol;\n        return protocol !== 'ws:' && protocol !== 'wss:';\n    }\n    return false;\n}\nexport class MCPConnection extends EventEmitter {\n    constructor(serverName, options, logger) {\n        super();\n        this.options = options;\n        this.logger = logger;\n        this.transport = null; // Make this nullable\n        this.connectionState = 'disconnected';\n        this.connectPromise = null;\n        this.lastError = null;\n        this.lastConfigUpdate = 0;\n        this.CONFIG_TTL = 5 * 60 * 1000; // 5 minutes\n        this.MAX_RECONNECT_ATTEMPTS = 3;\n        this.shouldStopReconnecting = false;\n        this.isReconnecting = false;\n        this.isInitializing = false;\n        this.reconnectAttempts = 0;\n        this.serverName = serverName;\n        this.logger = logger;\n        this.iconPath = options.iconPath;\n        this.client = new Client({\n            name: 'librechat-mcp-client',\n            version: '1.0.0',\n        }, {\n            capabilities: {},\n        });\n        this.setupEventListeners();\n    }\n    static getInstance(serverName, options, logger) {\n        if (!MCPConnection.instance) {\n            MCPConnection.instance = new MCPConnection(serverName, options, logger);\n        }\n        return MCPConnection.instance;\n    }\n    static getExistingInstance() {\n        return MCPConnection.instance;\n    }\n    static destroyInstance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (MCPConnection.instance) {\n                yield MCPConnection.instance.disconnect();\n                MCPConnection.instance = null;\n            }\n        });\n    }\n    emitError(error, errorContext) {\n        var _a;\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`[MCP][${this.serverName}] ${errorContext}: ${errorMessage}`);\n        this.emit('error', new Error(`${errorContext}: ${errorMessage}`));\n    }\n    constructTransport(options) {\n        var _a;\n        try {\n            let type;\n            if (isStdioOptions(options)) {\n                type = 'stdio';\n            }\n            else if (isWebSocketOptions(options)) {\n                type = 'websocket';\n            }\n            else if (isSSEOptions(options)) {\n                type = 'sse';\n            }\n            else {\n                throw new Error('Cannot infer transport type: options.type is not provided and cannot be inferred from other properties.');\n            }\n            switch (type) {\n                case 'stdio':\n                    if (!isStdioOptions(options)) {\n                        throw new Error('Invalid options for stdio transport.');\n                    }\n                    return new StdioClientTransport({\n                        command: options.command,\n                        args: options.args,\n                        env: options.env,\n                    });\n                case 'websocket':\n                    if (!isWebSocketOptions(options)) {\n                        throw new Error('Invalid options for websocket transport.');\n                    }\n                    return new WebSocketClientTransport(new URL(options.url));\n                case 'sse': {\n                    if (!isSSEOptions(options)) {\n                        throw new Error('Invalid options for sse transport.');\n                    }\n                    const url = new URL(options.url);\n                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`[MCP][${this.serverName}] Creating SSE transport: ${url.toString()}`);\n                    const transport = new SSEClientTransport(url);\n                    transport.onclose = () => {\n                        var _a;\n                        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`[MCP][${this.serverName}] SSE transport closed`);\n                        this.emit('connectionChange', 'disconnected');\n                    };\n                    transport.onerror = (error) => {\n                        var _a;\n                        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`[MCP][${this.serverName}] SSE transport error:`, error);\n                        this.emitError(error, 'SSE transport error:');\n                    };\n                    transport.onmessage = (message) => {\n                        var _a;\n                        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`[MCP][${this.serverName}] Message received: ${JSON.stringify(message)}`);\n                    };\n                    this.setupTransportErrorHandlers(transport);\n                    return transport;\n                }\n                default: {\n                    throw new Error(`Unsupported transport type: ${type}`);\n                }\n            }\n        }\n        catch (error) {\n            this.emitError(error, 'Failed to construct transport:');\n            throw error;\n        }\n    }\n    setupEventListeners() {\n        this.isInitializing = true;\n        this.on('connectionChange', (state) => {\n            this.connectionState = state;\n            if (state === 'connected') {\n                this.isReconnecting = false;\n                this.isInitializing = false;\n                this.shouldStopReconnecting = false;\n                this.reconnectAttempts = 0;\n            }\n            else if (state === 'error' && !this.isReconnecting && !this.isInitializing) {\n                this.handleReconnection().catch((error) => {\n                    var _a;\n                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`[MCP][${this.serverName}] Reconnection handler failed:`, error);\n                });\n            }\n        });\n        this.subscribeToResources();\n    }\n    handleReconnection() {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.isReconnecting || this.shouldStopReconnecting || this.isInitializing) {\n                return;\n            }\n            this.isReconnecting = true;\n            const backoffDelay = (attempt) => Math.min(1000 * Math.pow(2, attempt), 30000);\n            try {\n                while (this.reconnectAttempts < this.MAX_RECONNECT_ATTEMPTS &&\n                    !this.shouldStopReconnecting) {\n                    this.reconnectAttempts++;\n                    const delay = backoffDelay(this.reconnectAttempts);\n                    (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`[MCP][${this.serverName}] Reconnecting ${this.reconnectAttempts}/${this.MAX_RECONNECT_ATTEMPTS} (delay: ${delay}ms)`);\n                    yield new Promise((resolve) => setTimeout(resolve, delay));\n                    try {\n                        yield this.connect();\n                        this.reconnectAttempts = 0;\n                        return;\n                    }\n                    catch (error) {\n                        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(`[MCP][${this.serverName}] Reconnection attempt failed:`, error);\n                        if (this.reconnectAttempts === this.MAX_RECONNECT_ATTEMPTS ||\n                            this.shouldStopReconnecting) {\n                            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error(`[MCP][${this.serverName}] Stopping reconnection attempts`);\n                            return;\n                        }\n                    }\n                }\n            }\n            finally {\n                this.isReconnecting = false;\n            }\n        });\n    }\n    subscribeToResources() {\n        this.client.setNotificationHandler(ResourceListChangedNotificationSchema, () => __awaiter(this, void 0, void 0, function* () {\n            this.invalidateCache();\n            this.emit('resourcesChanged');\n        }));\n    }\n    invalidateCache() {\n        // this.cachedConfig = null;\n        this.lastConfigUpdate = 0;\n    }\n    connectClient() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connectionState === 'connected') {\n                return;\n            }\n            if (this.connectPromise) {\n                return this.connectPromise;\n            }\n            if (this.shouldStopReconnecting) {\n                return;\n            }\n            this.emit('connectionChange', 'connecting');\n            this.connectPromise = (() => __awaiter(this, void 0, void 0, function* () {\n                var _a;\n                try {\n                    if (this.transport) {\n                        try {\n                            yield this.client.close();\n                            this.transport = null;\n                        }\n                        catch (error) {\n                            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.warn(`[MCP][${this.serverName}] Error closing connection:`, error);\n                        }\n                    }\n                    this.transport = this.constructTransport(this.options);\n                    this.setupTransportDebugHandlers();\n                    const connectTimeout = 10000;\n                    yield Promise.race([\n                        this.client.connect(this.transport),\n                        new Promise((_resolve, reject) => setTimeout(() => reject(new Error('Connection timeout')), connectTimeout)),\n                    ]);\n                    this.connectionState = 'connected';\n                    this.emit('connectionChange', 'connected');\n                    this.reconnectAttempts = 0;\n                }\n                catch (error) {\n                    this.connectionState = 'error';\n                    this.emit('connectionChange', 'error');\n                    this.lastError = error instanceof Error ? error : new Error(String(error));\n                    throw error;\n                }\n                finally {\n                    this.connectPromise = null;\n                }\n            }))();\n            return this.connectPromise;\n        });\n    }\n    setupTransportDebugHandlers() {\n        if (!this.transport) {\n            return;\n        }\n        this.transport.onmessage = (msg) => {\n            var _a;\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`[MCP][${this.serverName}] Transport received: ${JSON.stringify(msg)}`);\n        };\n        const originalSend = this.transport.send.bind(this.transport);\n        this.transport.send = (msg) => __awaiter(this, void 0, void 0, function* () {\n            var _a;\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`[MCP][${this.serverName}] Transport sending: ${JSON.stringify(msg)}`);\n            return originalSend(msg);\n        });\n    }\n    connect() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                yield this.disconnect();\n                yield this.connectClient();\n                if (!this.isConnected()) {\n                    throw new Error('Connection not established');\n                }\n            }\n            catch (error) {\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`[MCP][${this.serverName}] Connection failed:`, error);\n                throw error;\n            }\n        });\n    }\n    setupTransportErrorHandlers(transport) {\n        transport.onerror = (error) => {\n            var _a;\n            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`[MCP][${this.serverName}] Transport error:`, error);\n            this.emit('connectionChange', 'error');\n        };\n        const errorHandler = (error) => {\n            var _a;\n            try {\n                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.error(`[MCP][${this.serverName}] Uncaught transport error:`, error);\n            }\n            catch (_b) {\n                console.error(`[MCP][${this.serverName}] Critical error logging failed`, error);\n            }\n            this.emit('connectionChange', 'error');\n        };\n        process.on('uncaughtException', errorHandler);\n        process.on('unhandledRejection', errorHandler);\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                if (this.transport) {\n                    yield this.client.close();\n                    this.transport = null;\n                }\n                if (this.connectionState === 'disconnected') {\n                    return;\n                }\n                this.connectionState = 'disconnected';\n                this.emit('connectionChange', 'disconnected');\n            }\n            catch (error) {\n                this.emit('error', error);\n                throw error;\n            }\n            finally {\n                this.invalidateCache();\n                this.connectPromise = null;\n            }\n        });\n    }\n    fetchResources() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { resources } = yield this.client.listResources();\n                return resources;\n            }\n            catch (error) {\n                this.emitError(error, 'Failed to fetch resources:');\n                return [];\n            }\n        });\n    }\n    fetchTools() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { tools } = yield this.client.listTools();\n                return tools;\n            }\n            catch (error) {\n                this.emitError(error, 'Failed to fetch tools:');\n                return [];\n            }\n        });\n    }\n    fetchPrompts() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const { prompts } = yield this.client.listPrompts();\n                return prompts;\n            }\n            catch (error) {\n                this.emitError(error, 'Failed to fetch prompts:');\n                return [];\n            }\n        });\n    }\n    // public async modifyConfig(config: ContinueConfig): Promise<ContinueConfig> {\n    //   try {\n    //     // Check cache\n    //     if (this.cachedConfig && Date.now() - this.lastConfigUpdate < this.CONFIG_TTL) {\n    //       return this.cachedConfig;\n    //     }\n    //     await this.connectClient();\n    //     // Fetch and process resources\n    //     const resources = await this.fetchResources();\n    //     const submenuItems = resources.map(resource => ({\n    //       title: resource.name,\n    //       description: resource.description,\n    //       id: resource.uri,\n    //     }));\n    //     if (!config.contextProviders) {\n    //       config.contextProviders = [];\n    //     }\n    //     config.contextProviders.push(\n    //       new MCPContextProvider({\n    //         submenuItems,\n    //         client: this.client,\n    //       }),\n    //     );\n    //     // Fetch and process tools\n    //     const tools = await this.fetchTools();\n    //     const continueTools: Tool[] = tools.map(tool => ({\n    //       displayTitle: tool.name,\n    //       function: {\n    //         description: tool.description,\n    //         name: tool.name,\n    //         parameters: tool.inputSchema,\n    //       },\n    //       readonly: false,\n    //       type: 'function',\n    //       wouldLikeTo: `use the ${tool.name} tool`,\n    //       uri: `mcp://${tool.name}`,\n    //     }));\n    //     config.tools = [...(config.tools || []), ...continueTools];\n    //     // Fetch and process prompts\n    //     const prompts = await this.fetchPrompts();\n    //     if (!config.slashCommands) {\n    //       config.slashCommands = [];\n    //     }\n    //     const slashCommands: SlashCommand[] = prompts.map(prompt =>\n    //       constructMcpSlashCommand(\n    //         this.client,\n    //         prompt.name,\n    //         prompt.description,\n    //         prompt.arguments?.map(a => a.name),\n    //       ),\n    //     );\n    //     config.slashCommands.push(...slashCommands);\n    //     // Update cache\n    //     this.cachedConfig = config;\n    //     this.lastConfigUpdate = Date.now();\n    //     return config;\n    //   } catch (error) {\n    //     this.emit('error', error);\n    //     // Return original config if modification fails\n    //     return config;\n    //   }\n    // }\n    // Public getters for state information\n    getConnectionState() {\n        return this.connectionState;\n    }\n    isConnected() {\n        return this.connectionState === 'connected';\n    }\n    getLastError() {\n        return this.lastError;\n    }\n}\nMCPConnection.instance = null;\n//# sourceMappingURL=connection.js.map","references":["/Users/romanzarvirov/aibuddy/LibreChat/node_modules/events/events.js","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/client/index.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/client/sse.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/client/stdio.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/client/websocket.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/types.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/shared/transport.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/winston/index.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/src/types/mcp.ts"],"map":"{\"version\":3,\"file\":\"connection.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/connection.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/dist/types/connection.d.ts","writeByteOrderMark":false,"text":"/// <reference types=\"node\" />\nimport { EventEmitter } from 'events';\nimport { Client } from '@modelcontextprotocol/sdk/client/index.js';\nimport type { Logger } from 'winston';\nimport type * as t from './types/mcp.js';\nexport declare class MCPConnection extends EventEmitter {\n    private readonly options;\n    private logger?;\n    private static instance;\n    client: Client;\n    private transport;\n    private connectionState;\n    private connectPromise;\n    private lastError;\n    private lastConfigUpdate;\n    private readonly CONFIG_TTL;\n    private readonly MAX_RECONNECT_ATTEMPTS;\n    readonly serverName: string;\n    private shouldStopReconnecting;\n    private isReconnecting;\n    private isInitializing;\n    private reconnectAttempts;\n    iconPath?: string;\n    constructor(serverName: string, options: t.MCPOptions, logger?: Logger | undefined);\n    static getInstance(serverName: string, options: t.MCPOptions, logger?: Logger): MCPConnection;\n    static getExistingInstance(): MCPConnection | null;\n    static destroyInstance(): Promise<void>;\n    private emitError;\n    private constructTransport;\n    private setupEventListeners;\n    private handleReconnection;\n    private subscribeToResources;\n    private invalidateCache;\n    connectClient(): Promise<void>;\n    private setupTransportDebugHandlers;\n    connect(): Promise<void>;\n    private setupTransportErrorHandlers;\n    disconnect(): Promise<void>;\n    fetchResources(): Promise<t.MCPResource[]>;\n    fetchTools(): Promise<import(\"zod\").objectOutputType<{\n        name: import(\"zod\").ZodString;\n        description: import(\"zod\").ZodOptional<import(\"zod\").ZodString>;\n        inputSchema: import(\"zod\").ZodObject<{\n            type: import(\"zod\").ZodLiteral<\"object\">;\n            properties: import(\"zod\").ZodOptional<import(\"zod\").ZodObject<{}, \"passthrough\", import(\"zod\").ZodTypeAny, import(\"zod\").objectOutputType<{}, import(\"zod\").ZodTypeAny, \"passthrough\">, import(\"zod\").objectInputType<{}, import(\"zod\").ZodTypeAny, \"passthrough\">>>;\n        }, \"passthrough\", import(\"zod\").ZodTypeAny, import(\"zod\").objectOutputType<{\n            type: import(\"zod\").ZodLiteral<\"object\">;\n            properties: import(\"zod\").ZodOptional<import(\"zod\").ZodObject<{}, \"passthrough\", import(\"zod\").ZodTypeAny, import(\"zod\").objectOutputType<{}, import(\"zod\").ZodTypeAny, \"passthrough\">, import(\"zod\").objectInputType<{}, import(\"zod\").ZodTypeAny, \"passthrough\">>>;\n        }, import(\"zod\").ZodTypeAny, \"passthrough\">, import(\"zod\").objectInputType<{\n            type: import(\"zod\").ZodLiteral<\"object\">;\n            properties: import(\"zod\").ZodOptional<import(\"zod\").ZodObject<{}, \"passthrough\", import(\"zod\").ZodTypeAny, import(\"zod\").objectOutputType<{}, import(\"zod\").ZodTypeAny, \"passthrough\">, import(\"zod\").objectInputType<{}, import(\"zod\").ZodTypeAny, \"passthrough\">>>;\n        }, import(\"zod\").ZodTypeAny, \"passthrough\">>;\n    }, import(\"zod\").ZodTypeAny, \"passthrough\">[]>;\n    fetchPrompts(): Promise<t.MCPPrompt[]>;\n    getConnectionState(): t.ConnectionState;\n    isConnected(): boolean;\n    getLastError(): Error | null;\n}\n"}}
