{"code":"import { __awaiter } from \"tslib\";\nimport { CallToolResultSchema } from '@modelcontextprotocol/sdk/types.js';\nimport { formatToolContent } from './parsers';\nimport { MCPConnection } from './connection';\nimport { CONSTANTS } from './enum';\nexport class MCPManager {\n    static getDefaultLogger() {\n        return {\n            error: console.error,\n            warn: console.warn,\n            info: console.info,\n            debug: console.debug,\n        };\n    }\n    constructor(logger) {\n        this.connections = new Map();\n        this.logger = logger || MCPManager.getDefaultLogger();\n    }\n    static getInstance(logger) {\n        if (!MCPManager.instance) {\n            MCPManager.instance = new MCPManager(logger);\n        }\n        return MCPManager.instance;\n    }\n    initializeMCP(mcpServers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.logger.info('[MCP] Initializing servers');\n            const entries = Object.entries(mcpServers);\n            const initializedServers = new Set();\n            const connectionResults = yield Promise.allSettled(entries.map(([serverName, config], i) => __awaiter(this, void 0, void 0, function* () {\n                const connection = new MCPConnection(serverName, config, this.logger);\n                connection.on('connectionChange', (state) => {\n                    this.logger.info(`[MCP][${serverName}] Connection state: ${state}`);\n                });\n                try {\n                    const connectionTimeout = new Promise((_, reject) => setTimeout(() => reject(new Error('Connection timeout')), 30000));\n                    const connectionAttempt = this.initializeServer(connection, serverName);\n                    yield Promise.race([connectionAttempt, connectionTimeout]);\n                    if (connection.isConnected()) {\n                        initializedServers.add(i);\n                        this.connections.set(serverName, connection);\n                        const serverCapabilities = connection.client.getServerCapabilities();\n                        this.logger.info(`[MCP][${serverName}] Capabilities: ${JSON.stringify(serverCapabilities)}`);\n                        if (serverCapabilities === null || serverCapabilities === void 0 ? void 0 : serverCapabilities.tools) {\n                            const tools = yield connection.client.listTools();\n                            if (tools.tools.length) {\n                                this.logger.info(`[MCP][${serverName}] Available tools: ${tools.tools\n                                    .map((tool) => tool.name)\n                                    .join(', ')}`);\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    this.logger.error(`[MCP][${serverName}] Initialization failed`, error);\n                    throw error;\n                }\n            })));\n            const failedConnections = connectionResults.filter((result) => result.status === 'rejected');\n            this.logger.info(`[MCP] Initialized ${initializedServers.size}/${entries.length} server(s)`);\n            if (failedConnections.length > 0) {\n                this.logger.warn(`[MCP] ${failedConnections.length}/${entries.length} server(s) failed to initialize`);\n            }\n            entries.forEach(([serverName], index) => {\n                if (initializedServers.has(index)) {\n                    this.logger.info(`[MCP][${serverName}] ✓ Initialized`);\n                }\n                else {\n                    this.logger.info(`[MCP][${serverName}] ✗ Failed`);\n                }\n            });\n            if (initializedServers.size === entries.length) {\n                this.logger.info('[MCP] All servers initialized successfully');\n            }\n            else if (initializedServers.size === 0) {\n                this.logger.error('[MCP] No servers initialized');\n            }\n        });\n    }\n    initializeServer(connection, serverName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const maxAttempts = 3;\n            let attempts = 0;\n            while (attempts < maxAttempts) {\n                try {\n                    yield connection.connect();\n                    if (connection.isConnected()) {\n                        return;\n                    }\n                }\n                catch (error) {\n                    attempts++;\n                    if (attempts === maxAttempts) {\n                        this.logger.error(`[MCP][${serverName}] Failed after ${maxAttempts} attempts`);\n                        throw error;\n                    }\n                    yield new Promise((resolve) => setTimeout(resolve, 2000 * attempts));\n                }\n            }\n        });\n    }\n    getConnection(serverName) {\n        return this.connections.get(serverName);\n    }\n    getAllConnections() {\n        return this.connections;\n    }\n    mapAvailableTools(availableTools) {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const [serverName, connection] of this.connections.entries()) {\n                try {\n                    if (connection.isConnected() !== true) {\n                        this.logger.warn(`Connection ${serverName} is not connected. Skipping tool fetch.`);\n                        continue;\n                    }\n                    const tools = yield connection.fetchTools();\n                    for (const tool of tools) {\n                        const name = `${tool.name}${CONSTANTS.mcp_delimiter}${serverName}`;\n                        availableTools[name] = {\n                            type: 'function',\n                            ['function']: {\n                                name,\n                                description: tool.description,\n                                parameters: tool.inputSchema,\n                            },\n                        };\n                    }\n                }\n                catch (error) {\n                    this.logger.warn(`[MCP][${serverName}] Not connected, skipping tool fetch`);\n                }\n            }\n        });\n    }\n    loadManifestTools(manifestTools) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            for (const [serverName, connection] of this.connections.entries()) {\n                try {\n                    if (connection.isConnected() !== true) {\n                        this.logger.warn(`Connection ${serverName} is not connected. Skipping tool fetch.`);\n                        continue;\n                    }\n                    const tools = yield connection.fetchTools();\n                    for (const tool of tools) {\n                        const pluginKey = `${tool.name}${CONSTANTS.mcp_delimiter}${serverName}`;\n                        manifestTools.push({\n                            name: tool.name,\n                            pluginKey,\n                            description: (_a = tool.description) !== null && _a !== void 0 ? _a : '',\n                            icon: connection.iconPath,\n                        });\n                    }\n                }\n                catch (error) {\n                    this.logger.error(`[MCP][${serverName}] Error fetching tools`, error);\n                }\n            }\n        });\n    }\n    callTool(serverName, toolName, provider, toolArguments) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = this.connections.get(serverName);\n            if (!connection) {\n                throw new Error(`No connection found for server: ${serverName}. Please make sure to use MCP servers available under 'Connected MCP Servers'.`);\n            }\n            const result = yield connection.client.request({\n                method: 'tools/call',\n                params: {\n                    name: toolName,\n                    arguments: toolArguments,\n                },\n            }, CallToolResultSchema);\n            return formatToolContent(result, provider);\n        });\n    }\n    disconnectServer(serverName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = this.connections.get(serverName);\n            if (connection) {\n                yield connection.disconnect();\n                this.connections.delete(serverName);\n            }\n        });\n    }\n    disconnectAll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const disconnectPromises = Array.from(this.connections.values()).map((connection) => connection.disconnect());\n            yield Promise.all(disconnectPromises);\n            this.connections.clear();\n        });\n    }\n    static destroyInstance() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (MCPManager.instance) {\n                yield MCPManager.instance.disconnectAll();\n                MCPManager.instance = null;\n            }\n        });\n    }\n}\nMCPManager.instance = null;\n//# sourceMappingURL=manager.js.map","references":["/Users/romanzarvirov/aibuddy/LibreChat/node_modules/@modelcontextprotocol/sdk/dist/types.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/data-provider/dist/types/index.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/node_modules/winston/index.d.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/src/types/mcp.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/src/parsers.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/src/connection.ts","/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/src/enum.ts"],"map":"{\"version\":3,\"file\":\"manager.js\",\"sourceRoot\":\"\",\"sources\":[\"../../src/manager.ts\"],\"names\":[],\"mappings\":\"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\"}","dts":{"name":"/Users/romanzarvirov/aibuddy/LibreChat/packages/mcp/dist/types/manager.d.ts","writeByteOrderMark":false,"text":"import type { Logger } from 'winston';\nimport type * as t from './types/mcp';\nimport { MCPConnection } from './connection';\nexport declare class MCPManager {\n    private static instance;\n    private connections;\n    private logger;\n    private static getDefaultLogger;\n    private constructor();\n    static getInstance(logger?: Logger): MCPManager;\n    initializeMCP(mcpServers: t.MCPServers): Promise<void>;\n    private initializeServer;\n    getConnection(serverName: string): MCPConnection | undefined;\n    getAllConnections(): Map<string, MCPConnection>;\n    mapAvailableTools(availableTools: t.LCAvailableTools): Promise<void>;\n    loadManifestTools(manifestTools: t.LCToolManifest): Promise<void>;\n    callTool(serverName: string, toolName: string, provider: t.Provider, toolArguments?: Record<string, unknown>): Promise<t.FormattedToolResponse>;\n    disconnectServer(serverName: string): Promise<void>;\n    disconnectAll(): Promise<void>;\n    static destroyInstance(): Promise<void>;\n}\n"}}
